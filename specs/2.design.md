# Design of aki-mline

## 1. Introduction

This document describes the internal design and architecture of the `aki-mline` command-line utility. The design is derived from the source code and is intended to satisfy the requirements outlined in `specs/1.acceptance-criteria.md`.

## 2. High-Level Architecture

The application is split into two main crates, following a common Rust CLI pattern:

1.  **`aki-mline` (Binary Crate):** The executable entry point (`main.rs`). Its responsibilities are minimal:
    *   Read command-line arguments from the environment.
    *   Set up standard I/O streams (stdin, stdout, stderr).
    *   Invoke the library crate's main execution function.
    *   Handle top-level errors and set the process exit code.

2.  **`libaki_mline` (Library Crate):** This crate (`lib.rs` and its modules) contains all the application's core logic. This separation makes the logic reusable, independently testable, and decoupled from the command-line environment.

## 3. Component Breakdown (Modules)

The `libaki_mline` crate is organized into several modules, each with a distinct responsibility.

### `main.rs` - Application Entry

- **Purpose:** The executable entry point.
- **Responsibilities:**
    - Gathers arguments using `std::env::args()`.
    - Instantiates I/O streams via `runnel::RunnelIoeBuilder`.
    - Calls `libaki_mline::execute()` to run the application logic.
    - Prints any returned error to `stderr` and exits with a non-zero status code.

### `lib.rs` - Public Library Interface

- **Purpose:** To orchestrate the application flow and provide a clean public API.
- **`execute()`:** The primary public function. It creates an environment configuration (`EnvConf`) and calls `execute_env()`.
- **`execute_env()`:**
    1.  Calls `conf::parse_cmdopts()` to parse arguments into a `CmdOptConf` struct.
    2.  Handles `--help` and `--version` requests immediately after parsing, exiting early if they are present.
    3.  If parsing is successful, it calls `run::run()` with the command-line and environment configurations.

### `conf` Module - Configuration Management

- **Purpose:** To handle all configuration, from both command-line arguments and environment variables.
- **Files:** `conf/mod.rs`, `conf/parse.rs`
- **Structs:**
    - `CmdOptConf`: Holds all options parsed from the command line.
    - `EnvConf`: Holds configuration loaded from environment variables (`AKI_MLINE_COLOR_SEQ_ST`, `AKI_MLINE_COLOR_SEQ_ED`).
- **Dependencies:** Uses the `flood_tide` crate for parsing arguments and the `atty` crate to determine if `stdout` is a terminal for the `--color=auto` logic.

### `run.rs` - Core Processing Logic

- **Purpose:** To execute the main line-filtering and matching logic.
- **`run()`:**
    - Pre-compiles all regular expression patterns from the `CmdOptConf` for efficiency using the `regex` crate.
    - Calls `do_match_proc()` to perform the filtering.
    - Catches and handles `BrokenPipe` errors to allow for graceful exits (e.g., `aki-mline ... | head`).
- **`do_match_proc()`:**
    - Reads from the input stream line by line.
    - For each line, it calls `make_line_color_mark()` to determine if the line matches and to get a character-by-character map of matching segments.
    - Based on the result and the `--inverse` flag, it decides whether to print the line.
    - If the line is to be printed and color is enabled, it calls `make_out_s()` to construct the final colored output string.
- **`make_line_color_mark()`:** Iterates through all regex and simple string patterns (`naive_opt` crate) to find matches in a line. It produces a `Vec<bool>` (boolean mask) of the same length as the line, with `true` marking characters that are part of a match.
- **`make_out_s()`:** Uses the boolean mask to build the output string, wrapping the `true` segments with the configured color escape codes.

### `util` Module - Shared Utilities

- **Purpose:** To provide small, reusable components and custom types.
- **Files:** `util/mod.rs`, `util/err.rs`, `util/opt_*.rs`
- **Components:**
    - **Custom Option Types:** (`OptColorWhen`, `OptUcXParam`, `OptAroundNum`): These structs and enums provide type-safety for command-line options. They implement the `FromStr` trait, which allows `flood_tide` to parse string arguments directly into these custom types.
    - **`err.rs`:** Defines a `BrokenPipeError` trait, which provides a clean, high-level method to check for this specific I/O error without cluttering the main logic.

## 4. Data Flow

The primary data flow for processing text is as follows:

```
[stdin] -> RunnelIoe -> run::do_match_proc() -> [line processing] -> RunnelIoe -> [stdout]
```

1.  **Input:** Text is read from `stdin` via the `RunnelIoe` abstraction provided by the `runnel` crate.
2.  **Processing Loop:** The `do_match_proc` function in `run.rs` iterates through each line.
3.  **Matching:** For each line, `make_line_color_mark` checks for matches against the configured patterns.
4.  **Coloring:** If a match is found and color is enabled, `make_out_s` constructs a new string with ANSI color codes.
5.  **Output:** The resulting line (either the original or the colored version) is written to `stdout`, again via the `RunnelIoe` abstraction.

Configuration data flows from the command line (`std::env::args`) through `conf::parse_cmdopts` into the `CmdOptConf` struct, which is then passed down to the `run` module.
